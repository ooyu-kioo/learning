## これリファクタリングした方がいんじゃね？ってケース

- 不可思議な名前 => コード理解を低下させる
  - 関数名・変数名・フィールド名に違和感を感じないか => 「関数宣言の変更・変数名の変更・フィールド名の変更」

- 重複したコード => 変更性の低下
  - 同一クラス内の複数のmethodに同じ式がないか => 「関数の抽出・ステートメントのスライド」
  - subk流明日間に重複 => 「メソッドの引き上げ」

- 長い関数 => コードの自己記述性・再利用性・選択可能性を妨げる
  - 単純に長い => 「関数の抽出」
  - パラメータや一時変数が多いと抽出が妨げられる
    - 一時変数が多い => 「問い合わせによる一時変数の置き換え」
    - 長いパラメータリスト => 「パラメータオブジェクトの導入・オブジェクトそのものの受け渡し」
    - それでも割と残ってしまう => 「コマンドによる関数の置き換え」
  - 条件分岐 => 条件記述の分解
  - 長いswitch文 => 「関数の抽出(分岐内容を関数の呼び出しに置き換え)」
  - 同じ条件でのswitch分岐が多い => 「ポリモーフィズムによる条件記述の置き換え」
  - roop => roop部分とroop内部のコードを抽出して関数化
    - 抽出したroopに名前をつけづらい
      - = roopだけでないことをやっている
      - => 「ループの分離(独立したタスクに分解)」

- 長いパラメータリスト => 可読・変更性の低下
  - パラメータで渡されるobjからパラメータリスト中の他のデータを取得できる
    - => 「問い合わせによるパラメータの置き換え(取得できるデータを削減)」
  - 「オブジェクトそのものの受け渡し(元々のデータ構造を渡す)」
  - 複数のパラメータが常に一緒に渡される => 「パラメータオブジェクトの導入」
  - パラメータが振る舞いを変えるためのフラグとして使われている => 「フラグパラメータの削除」
  - 複数の関数がパラメータを共有している => 「関数群のクラスへの集約」

- グローバルなデータ => どこからでも変更でき、どこから変更されたか知る術がない
  - とりあえず「変数のカプセル化」
  - 次にclass・moduleに移動

- 変更可能なデータ => スコープが広い場合、同じものに違う値を期待した場合のエラー
  - 「変数のカプセル化(全ての値の変更を特定の関数を通してのみに制限)」
  - １つの変数が別の事項を表すために使用されている => 「変数の分離」
  - 「ステートメントのスライド・関数の抽出(データの変更を行う箇所と副作用のないコードを分離)」
  - API => 「問い合わせと更新の分離(呼び出しがわが必要な時以外副作用のあるコードを呼ばない)」
  - 「setterの削除(変数のスコープを狭める)」
  - いつでも計算で導出できるのに変更になっている => 「問い合わせによる導出変数の置き換え」
  - 「関数群のクラスへの集約・関数群の変換への集約(変数の値を変更する箇所を減らす)」
  - 内部構造にデータを含んでいる変数 => 「参照から値への変更」

- 変更の偏り = １つのmodule・classが異なる目的のために異なる変更をされる = 機能の分割が適切でない
  - 処理が順番に行われるのが自然 => 「フェーズの分離(両者の中間データを定義して分離)」
  - 呼び出し順が前後する => 適切なmoduleを新たに作り「関数の移動」
    - 関数が２つの異なる処理を行なっている => 移す前に「関数の抽出」
    - classの場合 => 「クラスの抽出」

- 変更の分散 = 変更を行うたびにあちこちのmoduleが少しずつ書き換わる場合
  - まず暫定として
    - 「関数のインライン化」「クラスのインライン化」
  - その後に
    - 「関数の移動・フィールドの移動(変更部分を１つmoduleにまとめる)」
    - 似たデータ構造を扱う関数群がある => 「関数群のクラスへの集約」
    - データ構造を変更・情報を付加する関数群がある => 「関数群の変換への集約」
    - 「フェーズの分離」

- 特性の横恋慕 = moduleの関数が内部より外部とのやりとりが多い状態
  - 必要に応じて「関数の抽出」を行い、「関数の移動(関数を必要なデータに近づける)」
  - 例外 => Strategy, Visitorパターンなどを利用する

- データの群れ = 複数のデータ群
  - フィールド
    - 「クラスの抽出(データ群をobjにする)」
  - methodの引数
    - 「パラメータオブジェクトの導入・オブジェクトそのものの受け渡し(パラメータ数を減らす)」
  - 特性の横恋慕で振る舞いを移せないか検討

- 基本データ型への執着 = 型を文字列など適切でない型に押し込めること
  - 「オブジェクトによるプリミティブの置き換え」
  - データが振るまいを変えるためシンボル
    - => 「サブクラスによるタイプコードの置き換え」
    - => 「ポリモーフィズムによる条件記述の置き換え」
  - 同じデータ型の集まりが何度も出てくる = データ群 => 「クラスの抽出・パラメータオブジェクトの導入」

- 重複したスイッチ文
  - switch/case, if/elseの構文で複数の箇所に同じ条件分岐が書かれている
    - => 「ポリモーフィズムによる条件記述の置き換え」

- ループ
  - 「パイプラインによるループの置き換え」

- 疑わしき一般化・怠け者の要素 = 不必要に用意されたclass・関数
  - 「関数・クラスのインライン化」, 「クラス階層の平坦化」
  - 未使用のパラメータを持つ関数 => 「関数宣言の変更」

- 一時的属性 = インスタンス変数の値が特定の状況でしか設定されないクラス
  - 「クラスの抽出・関数の移動(変数・それを使用する関数を切り出す)」
  - 「特殊ケースの導入(変数が無効な時の代替クラスを用意)」

- メッセージの連鎖 = メソッドチェーン => 変更性が低下
  - 「委譲の隠蔽」
  - 最終的に返されるobjが何に使用されるか
    - objを実際に使っている部分を「関数の抽出」で取り出し、「関数の移動」でまとめる

- 仲介人 = 過剰な委譲
  - 「仲介人の除去(実際に処理を行うobjに直接処理させる)」
  - 中間メソッドが少ない場合 => 「関数のインライン化(呼び出しがわにその部分を埋め込む)」

- インサイダー取引 = module間のデータのやりとりが活発な状態
  - 「関数の移動」,「フィールドの移動」
  - moduleが共通の興味を持っている場合 => 「委譲の隠蔽」
  - 「委譲によるスーパークラスの置き換え」
  - 「委譲によるサブクラスの置き換え」

- 巨大なクラス = インスタンス変数が多いようなクラス
  - まず
    - 「クラスの抽出」
  - 次にそのクラスに関して
    - 継承でまとめられそうなら
      - 「スーパークラスの抽出」「サクブラスによるタイプコードの置き換え」

- クラスのインターフェース不一致

- データクラス = 属性とgetter, setter以外持たないようなクラス
  - 「レコードのカプセル化」
  - 変更されたら都合の悪い属性 => 「setterの削除」
  - 「関数の移動(アクセス元の振る舞いをデータクラスに移す)」

- 相続拒否 = subクラスがsuperクラスのほんの一部しか利用していない状態
  - = 継承の階層が間違っている => subクラスを新たに作り「メソッドの押し下げ」「フィールドの押し下げ」
  - subクラスがsuperクラスの振る舞いは継承するが、インターフェースは必要としない場合
  - => 「委譲によるサブクラスの置き換え」「委譲によるスーパークラスの置き換え」

- コメント
  - 十分に分かりやすい実装 = コメントは必要ない